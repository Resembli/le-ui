---
title: Fixed Size List
---

Remember to import the component - it's not shown in the examples.

```js
import { List } from "@resembli/le-window"
```

## Basic Example

import { List } from "@resembli/le-window"

```jsx live
function FixedSizeListExample() {
  const someItems = [
    ["Apples 🍎", "Keeps the doctor away", 200],
    ["Pear 🍐", "People think it's an apple", 300],
    ["Cherries 🍒", "Not berries", 400],
    ["Strawberry 🍓", "The best berries", 500],
    ["Burger 🍔", "Nice any time of the day", 600],
    ["Pizza 🍕", "Cheesey goodness", 700],
    ["Meat 🍖", "To stay strong", 800],
    ["Chicken Leg 🍗", "I hope the chicken is alright", 900],
  ]

  const data = Array(1000)
    .fill(0)
    .map((_, i) => {
      const index = i % someItems.length
      const props = {
        item: someItems[index][0],
        desc: someItems[index][1],
        price: someItems[index][2],
      }
      return { props }
    })

  const ItemComponent = (props) => {
    return (
      <div
        className="small-font-for-mobile"
        style={{
          display: "inline-grid",
          paddingLeft: "1rem",
          paddingRight: "1rem",
          gridTemplateColumns: "1fr 2fr auto",
          width: "100%",
          alignItems: "center",
          borderBottom: "1px solid grey",
          height: "100%",
        }}
      >
        <div>{props.item}</div>
        <div>{props.desc}</div>
        <div style={{ color: "green", fontWeight: "bold" }}>${props.price}</div>
      </div>
    )
  }

  return (
    <div style={{ height: 250, border: "1px solid grey" }}>
      <List data={data} defaultRowHeight={50} ItemComponent={ItemComponent} />
    </div>
  )
}
```

## Asynchrono List Items with React Suspense Example

:::caution
It's not recommened to data load within the `ItemComponent` passed to the `List` component without some form
of request caching.

Components that are "in-view" and subsequently moved "out-of-view" will be unmounted. If a
user is scrolling quickly (or jumping from place to place in the list) there will be a large series of mounts and
unmounts. Your data fetching logic will need to take this into account.
:::

```jsx live
function AsyncFixedSizeListExample() {
  const cache = useMemo(() => ({}), [])

  const resource = useMemo(() => {
    const read = (index) => {
      if (cache[index] !== undefined) return cache[index]

      throw new Promise((res) => {
        setTimeout(() => {
          // Since we aren't cleaning up setTimeouts of previous
          // renders in a useEffect, we no-op if the cache is already set.
          // DON'T DO THIS IN PRODUCTION CODE!
          if (cache[index] !== undefined) {
            res()
            return
          }

          cache[index] = Math.random() * 1000
          res()
        }, Math.random() * 1000)
      })
    }

    return { read }
  }, [cache])

  const AsyncItem = ({ index }) => {
    const randomValue = resource.read(index)

    return <div style={{ textAlign: "center" }}>My random value is {randomValue}</div>
  }

  const SuspenseItem = ({ index }) => {
    return (
      <Suspense
        fallback={
          <div className="center">
            <BeatLoader color="grey" />
          </div>
        }
      >
        <AsyncItem index={index} />
      </Suspense>
    )
  }

  const data = Array(1000)
    .fill(0)
    .map((_, i) => ({ props: { index: i } }))

  return (
    <div style={{ height: 250, border: "1px solid grey" }}>
      <List data={data} defaultRowHeight={50} ItemComponent={SuspenseItem} />
    </div>
  )
}
```
